use std.collections.Array

pub fn str.from_utf8_unchecked(bytes: [u8]) -> str =
	unsafe transmute[_](bytes)

pub fn str.from_utf8_unchecked(bytes: &[u8]) -> &str =
	unsafe transmute[_](bytes)

pub fn str.from_utf8_mut_unchecked(bytes: &mut [u8]) -> &mut str =
	unsafe transmute[_](bytes)

pub fn as_bytes(self: &str) -> &[u8] = 
	unsafe transmute[_](self)

pub type StrBuf(array: Array[u8])

pub fn StrBuf.new() -> StrBuf = StrBuf.with_cap(1)

pub fn StrBuf.with_cap(cap: uint) -> StrBuf = {
	let mut buf = StrBuf(Array.from([0]))
	buf.array.push(0) # TODO: null byte
	buf
}

pub fn len(self: &StrBuf) -> uint = self.array.len() - 1
pub fn cap(self: &StrBuf) -> uint = self.array.cap()
pub fn is_empty(self: &StrBuf) -> bool = self.len() == 0

pub fn as_ref(self: &StrBuf) -> &str =
	str.from_utf8_unchecked(self.array.as_ref())

pub fn as_mut(self: &mut StrBuf) -> &mut str =
	str.from_utf8_mut_unchecked(self.array.as_mut())

pub fn take(self: StrBuf) -> str =
	str.from_utf8_unchecked(self.array.take())

pub fn push(self: &mut StrBuf, s: &str) = {
	let bytes = s.as_bytes()
	self.array.reserve(bytes.len)
	# self.array.set(self.array.len() - 1, 0) # TODO: null byte
}
