import std.(c, io)

// TODO: Use lower-level `open` C api with flags
// TODO: Add an API for custom file opening with `OpenOptions`
fn open*(path: &str) -> io.Result[File] = {
    let pathname = unsafe as[_](path.as-bytes().ptr)
    // TODO: cross-platform open
    let fd = unsafe c.open(pathname, c.O_RDONLY, 0)

    if fd != -1 {
	Result.Ok(File(fd))
    } else {
	Result.Err(io.Error.last-os-error())
    }
}

type RawFd = c.c-int
type File*(fd: RawFd)

let default-buf-size: uint = 512
// let default-buf-size: uint = 8 * 1024

fn read-to-end*(self: &File) -> io.Result[Array[u8]] = {
    // TODO: initialize cap to file's size (or 0 if reading size fails)
    // TODO: implement `Array.filled(T, uint) where T: Copy`
    let mut a = Array.with-cap(default-buf-size)
    a.extend-zeroes()

    // TODO: read until end with a moving cursor, until result is 0
    match self.read(a.as-mut()) {
	Result.Ok(0) -> Result.Ok(a)
	Result.Ok(n) -> todo()
	Result.Err(err) -> Result.Err(err) 
    }
}

// TODO: remove in favor of Array.filled
fn extend-zeroes(a: &mut Array[u8]) = {
    let mut i = a.len()
    let cap = a.cap()
    for if i < cap {
	a.push(0)
	i += 1
    }
}

fn read*(self: &File, buf: &mut []u8) -> io.Result[uint] = {
    let len = unsafe c.read(self.fd, buf.ptr, buf.len)

    if len != -1 {
	Result.Ok(len)
    } else {
	Result.Err(io.Error.last-os-error())
    }
}
