import std.(c, io)

// TODO: Use lower-level `open` C api with flags
// TODO: Add an API for custom file opening with `OpenOptions`
fn open*(path: &str) -> io.Result[File] = {
    let pathname = unsafe as[_](path.as-bytes().ptr)
    // TODO: cross-platform open
    let fd = unsafe c.open(pathname, c.O_RDONLY, 0)

    if fd != -1 {
	Result.Ok(File(fd))
    } else {
	Result.Err(io.Error.last-os-error())
    }
}

type RawFd = c.c-int
type File*(fd: RawFd)

let default-buf-size: uint = 8 * 1024

fn read-to-end*(self: &File) -> io.Result[Array[u8]] = {
    // TODO: initialize with-cap to file's size (or 0 if reading size fails)
    // TODO: implement `Array.filled(T, uint) where T: Copy`
    let mut buf = Array.new[u8]()

    // TODO: implement `std.slice.filled(T, uint) where T: Copy`
    let mut scratch: []u8 = [:default-buf-size]
    unsafe scratch.len = default-buf-size

    for {
	match self.read(&mut scratch) {
	    Result.Ok(0) -> break
	    Result.Ok(len) -> {
		// TODO: Implement `std.array.extend([]T)`
		buf.reserve(len)

		let mut i = 0
		for if i < len {
		    buf.push-unchecked(scratch.[i])
		    i += 1
		}
	    }
	    Result.Err(err) -> return Result.Err(err) 
	}
    }

    Result.Ok(buf)
}


fn read-to-str*(self: &File) -> io.Result[str] = {
    let buf = match self.read-to-end() {
	Result.Ok(buf) -> buf
	Result.Err(err) -> return Result.Err(err) 
    }

    // TODO: utf8 check. if fails, return `io.Error.InvalidData(stream did not contain valid UTF-8)`
    Result.Ok(str.from-utf8-unchecked(buf.take()))
}

fn read*(self: &File, buf: &mut []u8) -> io.Result[uint] = {
    let len = unsafe c.read(self.fd, buf.ptr, buf.len)

    if len != -1 {
	Result.Ok(len)
    } else {
	Result.Err(io.Error.last-os-error())
    }
}

fn close*(self: File) = {
    unsafe c.close(self.fd)
}
