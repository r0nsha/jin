import std.(c, io)

// TODO: Use lower-level `open` C api with flags
// TODO: Add an API for custom file opening with `OpenOptions`
fn open*(path: &str) -> io.Result[File] = {
    let pathname = unsafe as[_](path.as-bytes().ptr)
    // TODO: cross-platform open
    let fd = unsafe c.open(pathname, c.O_RDONLY, 0)

    if fd != -1 {
	Result.Ok(File(fd))
    } else {
	Result.Err(io.Error.last-os-error())
    }
}

type RawFd = c.c-int
type File*(fd: RawFd)

let default-buf-size: uint = 8 * 1024

fn read-to-end*(self: &File) -> io.Result[Array[u8]] = {
    // TODO: initialize cap to file's size (or 0 if reading size fails)
    // TODO: implement `Array.filled(T, uint) where T: Copy`
    let mut a = Array.with-cap(default-buf-size)

    let mut i = 0
    for if i < a.cap() {
	a.push(0)
	i += 1
    }

    // TODO: read until end with a moving cursor, until result is 0
    self.read(a.as-mut())
    Result.Ok(a)
}

fn read*(self: &File, buf: &mut []u8) -> io.Result[uint] = {
    let len = unsafe c.read(self.fd, buf.ptr, buf.len)

    if len == -1 {
	return Result.Err(io.Error.last-os-error())
    }

    println("{len}")
    Result.Ok(len)
}
