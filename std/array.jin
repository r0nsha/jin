use std.builtin
use std.option.Option

pub type Array[T](buf: [T])

pub fn Array.new[T]() -> Array[T] = Array([])

pub fn Array.new[T](len: UInt, f: fn(UInt) -> T) -> Array[T] = {
	let mut array = Array.with_cap(len)
	let mut i = 0

	for if i < len {
		array.push(f(i))
		i += 1
	}

	array
}

pub fn Array.with_cap[T](cap: UInt) -> Array[T] = Array([:cap])

pub fn len[T](self: &Array[T]) -> UInt = self.buf.len
pub fn cap[T](self: &Array[T]) -> UInt = self.buf.cap
pub fn is_empty[T](self: &Array[T]) -> Bool = self.len() == 0

pub fn as_ref[T](self: &Array[T]) -> &[T] = &self.buf
pub fn as_mut[T](self: &mut Array[T]) -> &mut [T] = &mut self.buf
pub fn take[T](self: Array[T]) -> [T] = self.buf

pub fn get[T](self: &Array[T], index: UInt) -> Option[&T] = {
	if index < self.buf.len {
		Option.Some(&self.buf.[index])
	} else {
		Option.None
	}
}

pub fn push[T](self: &mut Array[T], value: T) = {
	if self.buf.len == self.buf.cap {
		self.grow()
	}
	unsafe self.buf.len += 1
	self.buf.[self.buf.len - 1] = value
}

pub fn pop[T](self: &mut Array[T]) -> Option[T] = {
	if self.buf.len == 0 {
		return Option.None
	}

	unsafe self.buf.len -= 1
	Option.Some(unsafe {self.buf.ptr + self.buf.len}.*)
}

pub fn clear[T](self: &mut Array[T]) = {
	self.buf = []
}

fn grow[T](self: &mut Array[T]) = {
	let new_cap = if self.buf.cap == 0 {
		min_cap
	} else {
		self.buf.cap * 2
	}

	let new_buf = unsafe builtin.grow(unsafe transmute[[T]](&mut self.buf), new_cap)
	let old = self.buf := new_buf
	unsafe builtin.forget(&old)
}

let min_cap: UInt = 4
