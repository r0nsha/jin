use std.builtin
use std.option.Option

type Array*[T](buf: []T)

fn Array.new*[T]() -> Array[T] = Array([])

fn Array.new*[T](len: uint, f: fn(uint) -> T) -> Array[T] = {
	let mut array = Array.with_cap(len)
	let mut i = 0

	for if i < len {
		array.push(f(i))
		i += 1
	}

	array
}

fn Array.from*[T](slice: []T) -> Array[T] = Array(slice)

fn Array.with_cap*[T](cap: uint) -> Array[T] = {
	// TODO: use a polymorphic `std.cmp.max` function for this	
	let c = if cap > min_cap { cap } else { min_cap }
	Array([:c])
}

fn len*[T](self: &Array[T]) -> uint = self.buf.len
fn cap*[T](self: &Array[T]) -> uint = self.buf.cap
fn is_empty*[T](self: &Array[T]) -> bool = self.len() == 0

fn as_ref*[T](self: &Array[T]) -> &[]T = &self.buf
fn as_mut*[T](self: &mut Array[T]) -> &mut []T = &mut self.buf
fn take*[T](self: Array[T]) -> []T = self.buf

fn get*[T](self: &Array[T], index: uint) -> Option[&T] = {
	if index < self.buf.len {
		Option.some(&self.buf.[index])
	} else {
		Option.none
	}
}

fn set*[T](self: &mut Array[T], index: uint, value: T) -> Option[T] = {
	if index < self.buf.len {
		Option.some(self.buf.[index] := value)
	} else {
		Option.none
	}
}

fn push*[T](self: &mut Array[T], value: T) = {
	self.reserve(1)
	self.push_unchecked(value)
}

fn pop*[T](self: &mut Array[T]) -> Option[T] = {
	if self.buf.len == 0 {
		return Option.none
	}

	unsafe self.buf.len -= 1
	Option.some(unsafe (self.buf.ptr + self.buf.len).0)
}

fn clear*[T](self: &mut Array[T]) = {
	self.buf = []
}

fn reserve*[T](self: &mut Array[T], additional: uint) = {
	if self.needs_to_grow(additional) {
		self.grow(additional)
	}
}

// TODO: this should be marked `unsafe`
fn push_unchecked*[T](self: &mut Array[T], value: T) = {
	unsafe self.buf.len += 1
	self.buf.[self.buf.len - 1] = value
}

// TODO: this should be marked `unsafe`
fn set_len*[T](self: &mut Array[T], len: uint) = {
	unsafe self.buf.len = len
}

fn needs_to_grow[T](self: &Array[T], additional: uint) -> bool =
	// TODO: this is prone to overflow, we should implement checked arithmetic
	self.buf.len + additional > self.buf.cap


fn grow[T](self: &mut Array[T], additional: uint) = {
	if self.buf.cap > 0 {
		let new_cap = max(self.buf.cap * 2, self.buf.cap + additional)
		unsafe builtin.grow(&mut self.buf, new_cap)
	} else {
		self.buf = [:min_cap]
	}
}

// TODO: use a polymorphic `std.cmp.max` function instead
fn max(a: uint, b: uint) -> uint =
	if a > b { a } else { b }

let min_cap: uint = 4
