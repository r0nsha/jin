import std.intrinsics
import std.option.{Option}

type Array*[a](buf: [a])

fn Array.new*[a]() Array[a] = Array([])

fn Array.new*[a](len: uint, f: fn(uint) a) Array[a] = {
	let mut array = Array.with_cap(len)
	let mut i = 0

	loop if i < len {
		array.push(f(i))
		i += 1
	}

	array
}

fn Array.with_cap*[a](cap: uint) Array[a] = Array([:cap])

fn len*[a](self: &Array[a]) uint = self.buf.len
fn cap*[a](self: &Array[a]) uint = self.buf.cap
fn is_empty*[a](self: &Array[a]) bool = self.len() == 0

fn as_ref*[a](self: &Array[a]) &[a] = &self.buf
fn as_mut*[a](self: &mut Array[a]) &mut [a] = &mut self.buf

fn get*[a](self: &Array[a], index: uint) Option[&a] = {
	if index < self.buf.len {
		Option.some(&self.buf.[index])
	} else {
		Option.none
	}
}

fn push*[a](self: &mut Array[a], value: a) unit = {
	if self.buf.len == self.buf.cap {
		self.grow()
	}
	self.buf.len += 1
	self.buf.[self.buf.len - 1] = value
}

fn pop*[a](self: &mut Array[a]) Option[a] = {
	if self.buf.len == 0 {
		Option.none
	} else {
		Option.none
		// TODO: self.len -= 1
		// TODO: Option.some({self.buf.ptr + self.buf.len}.*)
	}
}

fn grow[a](self: &mut Array[a]) unit = {
	let new_cap = if self.buf.cap == 0 {
		MIN_CAP
	} else {
		self.buf.cap * 2
	}

	let new_buf = intrinsics.grow(transmute[[a]](&mut self.buf), new_cap)
	let old = self.buf := new_buf
	intrinsics.forget(&old)
}

let MIN_CAP = 4
