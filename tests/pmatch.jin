use .inner

fn extern "c" printf(fmt: ptr[U8], ..) -> I32

fn main() = {
	match_vars()
	match_unit()
	match_bool(true)
	match_bool(false)

	match_int(42)
	match_int(-3)
	match_int(69)

	match_uint(42)
	match_uint(3)
	match_uint(69)

	match_str("foo")
	match_str("bar")
	match_str("hadas")

	match_types()
	match_guard()

	print_fac(10)
	print_fib(20)
}

fn match_vars() = {
	match true {
		mut x -> {
			x = false
			unsafe printf("x = %d\n".data, x)
			{}
		}
		_ -> {
			# ignored...
		}
	}
}


fn match_unit() = {
	match {} {
		{} -> unsafe printf("matched unit!\n".data)
		_ -> 1 # This branch is unreachable
	}
}

fn match_bool(value: Bool) = {
	unsafe printf("value = %s\n".data, match value {
		true -> "true"
		false -> "false"
		x -> "unreachable..."
	})
}

fn match_int(value: Int) = {
	match value {
		42 -> unsafe printf("i'm the answer\n".data)
		-3 -> unsafe printf("i'm -3\n".data)
		x -> unsafe printf("value is %d\n".data, x)
	}
}

fn match_uint(value: Uint) = {
	match value {
		42 -> unsafe printf("i'm still the answer\n".data)
		3 -> unsafe printf("i'm still 3\n".data)
		x -> unsafe printf("and value is %d\n".data, x)
	}
}

fn match_str(value: Str) = {
	match value {
		"foo" -> unsafe printf("i'm 'foo'\n".data)
		"bar" -> unsafe printf("i'm 'bar'\n".data)
		"foo" | "bar" -> unsafe printf("i'm 'foo' or 'bar\n".data)
		x -> unsafe printf("str is '%s'\n".data, x.data)
	}
}

type Box(value: Int)
type Bag(a: Box, b: Box)

fn match_types() = {
	let box = Box(1)

	match box {
		Box(1) -> { unsafe printf("it's 1!\n".data) }
		Box(v) -> print(v)
		Box(_) -> {} # unreachable
		_ -> {} # unreachable
	}

	let bag = Bag(Box(1), Box(3))

	match bag {
		Bag(Box(1), _) -> { unsafe printf("a: 1, b: _\n".data) }
		Bag(b: Box(3), a: Box(a)) -> { unsafe printf("a: %d, b: 3 (named)\n".data, a) }
		Bag(Box(a), Box(3)) -> { unsafe printf("a: %d, b: 3\n".data, a) }
		Bag(a, ..) -> move_(a)
		_ -> {} # unreachable
	}

	# print(bag)

	# match inner.get(1) {
	# 	#inner.Inner(field: 1) -> {} # Error: match private field
	# 	inner.Inner(..) -> {} # Ok, field isn't used
	# }
}

fn print(box: &Box) = {
	unsafe printf("Box(%d)\n".data, box.value)
}

fn print(bag: &Bag) = {
	match bag {
		Bag(a, b) -> {
			unsafe printf("Bag(a: Box(%d), b: Box(%d))\n".data, a.value, b.value)
			{}
		}
	}
}

fn print(value: Int) = {
	unsafe printf("%d\n".data, value)
}

fn move_(box: Box) = {}

fn match_guard() = {
	let foo = true
	match foo {
		_ if foo -> { unsafe printf("foo=true (guard)\n".data) }
		true -> { unsafe printf("foo=true\n".data) }
		false -> { unsafe printf("foo=false\n".data) }
		foo -> { unsafe printf("foo=%d\n".data, foo) }
	}
}

fn print_fac(n: Int) = {
	unsafe printf("fac(%d) = %d\n".data, n, fac(n))
}	

fn fac(n: Int) -> Int =
	match n {
		0 | 1 -> 1
		n -> n * fac(n - 1)
	}

fn print_fib(n: Int) = {
	unsafe printf("fib(%d) = %d\n".data, n, fib(n))
}

fn fib(n: Int) -> Int =
	match n {
		0 | 1 -> n
		n -> fib(n - 1) + fib(n - 2)
	}
