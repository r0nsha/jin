fn extern "c" printf(fmt: Ptr[U8], ..) -> I32

fn main() = {
	let mut array = Array.new[Int]()

	println("Array push:")
	array.push(1)
	array.push(2)
	array.push(3)
	array.push(4)
	array.push(5)
	array.push(6)
	array.push(7)

	array.print()

	array.print_at(0)
	array.print_at(3)
	array.print_at(8)

	println("\nArray take:")
	let slice = array.take()
	slice.print()

	println("\nArray pop:")
	let mut array = Array.new[Int](7) fn(idx) { as[Int](idx + 10) }
	array.print()

	match array.pop() {
		Option.some(x) -> unsafe printf("popped = Some(%d)\n".data, x)
		Option.none -> unsafe printf("popped = None\n".data)
	}

	array.print()

	println("\nArray clear:")
	array.clear()
	array.print()
}

fn print_at(array: &Array[Int], idx: Uint) = {
	match array.get(idx) {
		Option.some(x) -> unsafe printf("array[%d] = Some(%d)\n".data, idx, x)
		Option.none -> unsafe printf("array[%d] = None\n".data, idx)
	}
}

fn print(array: &Array[Int]) = {
	array.as_ref().print()
}

fn print(slice: &[Int]) = {
	unsafe printf("[".data)
	let mut i = 0
	for if i < slice.len {
		unsafe printf("%d".data, slice.[i])
		if i < slice.len - 1 {
			unsafe printf(", ".data)
		}
		i += 1
	}
	unsafe printf("] | len=%d cap=%d\n".data, slice.len, slice.cap)
}
