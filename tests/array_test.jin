import std.array.{Array}
import std.option.{Option}
import std.io.{println}

fn extern "c" printf(fmt: *u8, ..) -> i32

fn main() = {
	let mut array = Array.new[int]()

	println("Array push:")
	array.push(1)
	array.push(2)
	array.push(3)
	array.push(4)
	array.push(5)
	array.push(6)
	array.push(7)

	array.print()

	array.print_at(0)
	array.print_at(3)
	array.print_at(8)

	println("\nArray take:")
	let slice = array.take()
	slice.print()

	println("\nArray pop:")
	let mut array = Array.new[int](7) fn(idx) { {idx + 10} as int }
	array.print()

	match array.pop() {
		Option.some(x) -> printf("popped = some(%d)\n".ptr, x)
		Option.none -> printf("popped = none\n".ptr)
	}

	array.print()

	println("\nArray clear:")
	array.clear()
	array.print()
}

fn print_at(array: &Array[int], idx: uint) = {
	match array.get(idx) {
		Option.some(x) -> printf("array[%d] = some(%d)\n".ptr, idx, x)
		Option.none -> printf("array[%d] = none\n".ptr, idx)
	}
}

fn print(array: &Array[int]) = {
	array.as_ref().print()
}

fn print(slice: &[int]) = {
	printf("[".ptr)
	let mut i = 0
	for if i < slice.len {
		printf("%d".ptr, slice.[i])
		if i < slice.len - 1 {
			printf(", ".ptr)
		}
		i += 1
	}
	printf("] | len=%d cap=%d\n".ptr, slice.len, slice.cap)
}
