type Box(value: int)

fn main() = {
	# Value constructors
	let a = Option.some(1)
	let b = Option.[int].some(1)
	let c = Option.some(value: 2)
	let d: Option[int] = Option.none

	# Pattern matching
	let value = Option.some(1)
	match &value {
		Option.some(1) -> println("some(1)")
		Option.some(_) -> println("some(other)")
		Option.none() -> println("none")
	}

	let o = Option.some(Box(4))

	let mut b = Box(1)
	println("before match: Box({b.value})")

	match o {
		Option.some(Box(value: 5)) -> println("some(Box(5))")
		Option.some(x) -> {
			println("some({x.value})")
			b = x
		}
		Option.none -> println("none")
	}

	println("after match: Box({b.value})")

	if Option.some(-1).map_or(false, is_negative) {
		println("o is negative")
	} else {
		println("o is not negative")
	}
}

fn is_negative(x: int) -> bool = x < 0
