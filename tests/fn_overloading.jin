use .child
use .child.{*}

fn extern "c" printf(fmt: *U8, ..) -> I32

fn main() = {
	unsafe printf("Function overload matching:\n".ptr)
	add(Int(1), Int(1)) # exact int
	add(1, 1) # untyped int matching
	add(8, 13, 9) # matching different arg count
	add(F32(1.0), F32(2.5)) # exact F32
	add(1.0, 2.5) # untyped float matching
	add(5, 2.25) # mixed parameter type matching
	unsafe printf("\n".ptr)

	unsafe printf("Same calls in UFCS style\n".ptr)
	Int(1).add(Int(1))
	1.add(1)
	8.add(13, 9)
	F32(1.0).add(F32(2.5))
	{1.0}.add(2.5)
	5.add(2.25)
	unsafe printf("\n".ptr)

	unsafe printf("Calls with named arguments:\n".ptr)
	named(x: 1) # picks `fn named(x: Int)`
	named[Int](x: 1) # picks `fn named[a](x: a)`
	named(1, 2) # picks `fn named(x: Int, y: Int)`
	named(y: 1, x: 2) # picks `fn named(x: Int, y: Int)`
	named(z: 1) # picks `fn named(z: Int)`
	unsafe printf("\n".ptr)

	unsafe printf("Chaining add calls with a print at the end:\n".ptr)
	1.add_one()
		.add_one()
		.add_one()
		.add(3)
	unsafe printf("\n".ptr)

	child.poly[Int](1) # picking a module function with type application
}

fn add_one(x: Int) -> Int = {
	x + 1
}

fn named(x: Int) = {
	unsafe printf("named: x = %d\n".ptr, x)
}

fn named(x: Int, y: Int) = {
	unsafe printf("named: x = %d, y = %d\n".ptr, x, y)
}

fn named(z: Int) = {
	unsafe printf("named: z = %d\n".ptr, z)
}

fn named[T](x: T) = {
	unsafe printf("named[a]: x = %d\n".ptr, x)
}
