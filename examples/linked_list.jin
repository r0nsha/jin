import std.option.{Option, ?}

fn extern printf(fmt: *u8, ..) i32

type LinkedList[a](
  tail: Option[&mut Node[a]],
  head: Option[Node[a]],
)

type Node[a](
  prev: Option[&mut Node[a]],
  data: a,
  next: Option[Node[a]],
)

fn new_linked_list[a]() LinkedList[a] = LinkedList(tail: Option.none, head: Option.none)
fn new_node[a](data: a) Node[a] = Node(prev: Option.none, data: data, next: Option.none)

fn push_front[a](self: &mut LinkedList[a], data: a) unit = {
  let mut node = new_node(data)
  let node_mut = &mut node

  match self.head := Option.some(node) {
    Option.some(old_head) -> {
      // old_head.prev = Option.some(node_mut)
      // node_mut.next = Option.some(old_head)
    },
    Option.none -> {
      self.tail = Option.some(node_mut)
    },
  }
}

fn print(self: &LinkedList[int]) unit = {
  let mut curr = &self.head

  // printf("[".ptr)

  loop {
    match curr {
      Option.some(v) -> {
        curr = &v.next
        // printf("%d".ptr, v.data)
        // if curr.is_some() {
        //   printf(", ".ptr)
        // }
      },
      Option.none -> break
    }
  }

  // printf("]\n".ptr)
}

fn main() unit = {
  let mut list = new_linked_list[int]()  
  // list.push_front(3)
  // list.push_front(2)
  list.push_front(1)
  list.print()
}
