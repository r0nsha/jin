import std.option.(Option)

fn extern "c" printf(fmt: *u8, ..) -> i32

type LinkedList[T](
    tail: Option[&mut Node[T]],
    head: Option[Node[T]],
)

fn LinkedList.new[T]() -> LinkedList[T] = LinkedList(tail: Option.None, head: Option.None)

type Node[T](
    prev: Option[&mut Node[T]],
    data: T,
    next: Option[Node[T]],
)

fn Node.new[T](data: T) -> Node[T] = Node(prev: Option.None, data: data, next: Option.None)

fn push_front[T](self: &mut LinkedList[T], data: T) = {
    let mut node = Node.new(data)
    let node_mut = &mut node

    match self.head := Option.Some(node) {
        Some(old_head) -> {
            old_head.prev = Option.Some(node_mut)
            node_mut.next = Option.Some(old_head)
        }
        None -> self.tail = Option.Some(node_mut)
    }
}

fn print(self: &LinkedList[int]) = {
    let mut curr = &self.head

    printf("[".ptr)

    for {
        match curr {
            Some(v) -> {
                curr = &v.next
                printf("%d".ptr, v.data)
                if curr.is_some() {
                    printf(", ".ptr)
                }
            }
            None -> break
        }
    }

    printf("]\n".ptr)
}

fn main() = {
    let mut list = LinkedList.new()
    list.push_front(3) 
    list.push_front(2) 
    list.push_front(1) 
    list.print() 
}
