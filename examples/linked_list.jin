fn extern "c" printf(fmt: Ptr[U8], ..) -> I32

type LinkedList[T](
    tail: Option[&mut Node[T]],
    head: Option[Node[T]],
)

fn LinkedList.new[T]() -> LinkedList[T] = LinkedList(tail: Option.none, head: Option.none)

type Node[T](
    prev: Option[&mut Node[T]],
    data: T,
    next: Option[Node[T]],
)

fn Node.new[T](data: T) -> Node[T] = Node(prev: Option.none, data: data, next: Option.none)

fn push_front[T](self: &mut LinkedList[T], data: T) = {
    let mut node = Node.new(data)
    let node_mut = &mut node

    match self.head := Option.some(node) {
        Option.some(old_head) -> {
            old_head.prev = Option.some(node_mut)
            node_mut.next = Option.some(old_head)
        }
        Option.none -> self.tail = Option.some(node_mut)
    }
}

fn print(self: &LinkedList[Int]) = {
    let mut curr = &self.head

    unsafe printf("[".data)

    for {
        match curr {
            Option.some(v) -> {
                curr = &v.next
                unsafe printf("%d".data, v.data)
                if curr.is_some() {
                    unsafe printf(", ".data)
                }
            }
            Option.none -> break
        }
    }

    unsafe printf("]\n".data)
}

fn main() = {
    let mut list = LinkedList.new()
    list.push_front(3) 
    list.push_front(2) 
    list.push_front(1) 
    list.print() 
}
