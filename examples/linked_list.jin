import std.option.{Option}

fn extern printf(fmt: *u8, ..) i32

type LinkedList[a](
  tail: Option[&mut Node[a]],
  head: Option[Node[a]],
)

fn LinkedList.new[a]() LinkedList[a] = LinkedList(tail: Option.none, head: Option.none)

type Node[a](
  prev: Option[&mut Node[a]],
  data: a,
  next: Option[Node[a]],
)

fn Node.new[a](data: a) Node[a] = Node(prev: Option.none, data: data, next: Option.none)

fn push_front[a](self: &mut LinkedList[a], data: a) unit = {
  let mut node = Node.new(data)
  let node_mut = &mut node

  match self.head := Option.some(node) {
    Option.some(old_head) -> {
      old_head.prev = Option.some(node_mut)
      node_mut.next = Option.some(old_head)
    },
    Option.none -> {
      self.tail = Option.some(node_mut)
    },
  }
}

fn print(self: &LinkedList[int]) unit = {
  let mut curr = &self.head

  printf("[".ptr)

  loop {
    match curr {
      Option.some(v) -> {
        curr = &v.next
        printf("%d".ptr, v.data)
        if curr.is_some() {
          printf(", ".ptr)
        }
      },
      Option.none -> break
    }
  }

  printf("]\n".ptr)
}

fn main() unit = {
  let mut list = LinkedList.new()  
  list.push_front(3)
  list.push_front(2)
  list.push_front(1)
  list.print()
}
